
		“设计模式是被发现，而不是被发明出来的“



设计模式重要的部分可能就是它的名称。给模式起名的好处是大家相互交流时有共同的词汇。因此，如果你提交一些代码进行评审，
同行评审者的反	馈中提 到“我认为这个地方你可以使用一个策略模式来代替……”，即使你不知道或不记得策略模式是 什么，也可以立即去查阅。
随着编程语言的演进，一些设计模式（如单例）也随之过时，甚至成了反模式，另一些则被内置在编程语言中（如迭代器模式）。
另外，也有一些新的模式诞生（比如Borg/Monostate）

关于设计模式有一些误解。第一个误解是，一开始写代码就应该使用设计模式。第二个误解是设计模式应随处使用。这会导致方案很复杂，夹杂着多余的接口
和分层，而其实往往一个更简单直接的方案就足够了。设计模式并不是万能的，仅当代码确实存在坏味道、难以扩展维护时，才有使用的必要。



第一部分，创建型模式，介绍处理对象创建的设计模式。
	第1章，工厂模式介绍如何使用工厂设计模式（工厂方法和抽象工厂）来初始化对象，并说明与直接实例化对象相比，使用工厂设计模式的优势
	第2章，建造者模式 对于由多个相关对象构成的对象，介绍如何简化其创建过程。
	第3章，原型模式 介绍如何通过完全复制（也就是克隆）一个已有对象来创建一个新对象。

第二部分，结构型模式，介绍处理一个系统中不同实体（类、对象等）之间关系的设计模式。
 	第4章，适配器模式 介绍如何以小的改变实现已有代码与外来接口（例如，一个外部代码库）的兼容。
 	第5章，修饰器模式 介绍如何无需使用继承也能增强对象的功能。
 	第6章，外观模式 介绍如何创建单个入口点来隐藏系统的复杂性。
 	第7章，享元模式 介绍如何通过复用一个对象池中的对象来提高内存利用率及应用性能。
 	第8章，模型—视图—控制器模式 介绍如何避免业务逻辑与用户界面代码的耦合，提高应用的可维护性。
 	第9章，代理模式 介绍如何增加额外的保护层，提高应用的安全性。

第三部分，行为型模式，介绍处理系统实体之间通信的设计模式。
	第10章，责任链模式 介绍如何向多个接收者发送请求。
	第11章，命令模式 介绍如何让应用能够取消已经执行的操作。
	第12章，解释器模式 介绍如何基于Python创建一种简单的语言，便于领域专家使用，而无需学习Python编程。
	第13章，观察者模式 介绍如何在对象发生变化时，通知已注册的相关者。
	第14章，状态模式 介绍如何创建一个状态机以对问题进行建模，并说明这种技术的优势。
	第15章，策略模式 介绍如何基于某些输入标准（例如，元素大小）在程序运行期间从多个可用算法中选择一个。
	第16章，模板模式 介绍如何明确区分一个算法的通用与不通用部分，以避免不必要的代码复制。





创建型设计模式
	处理对象创建相关的问题，目标是当直接创建对象（在Python中是通过__init__()函数实现的，不太方便时，提供更好的方式。


	1.工厂模式：
		在工厂设计模式中，客户端可以请求一个对象，而无需知道这个对象来自哪里；也就是，使用哪个类来生成这个对象。工厂背后的思想是简化
		对象的创建。与客户端自己基于类实例化直 接创建对象相比，基于一个中心化函数来实现，更易于追踪创建了哪些对象。
		通过将创建对象的代码和使用对象的代码解耦，工厂能够降低应用维护的复杂度。

		工厂通常有两种形式：
			第一种是工厂方法（Factory Method），它是一个方法（或以地道的Python 术语来说，是一个函数），对不同的输入参数返回不同的对象；

			第二种是抽象工厂，它是一组用于创建一系列相关事物对象的工厂方法

		工厂方法：
			在工厂方法模式中，我们执行单个函数，传入一个参数（提供信息表明我们想要什么），但并不要求知道任何关于对象如何实现以及对象
			来自哪里的细节。

			现实生活的例子：
				现实中用到工厂方法模式思想的一个例子是塑料玩具制造。制造塑料玩具的压塑粉都是一样的，但使用不同的塑料模具就能
				产出不同的外形。比如，有一个工厂方法，输入是目标外形（鸭 子或小车）的名称，输出则是要求的塑料外形。

			软件的例子：
				Django框架使用工厂方法模式来创建表单字段。Django的forms模块支持不同种类字段（CharField、EmailField）的创建和
				定制（max_length、required）

			应用案例：
				如果因为应用创建对象的代码分布在多个不同的地方，而不是仅在一个函数方法中，你发现没法跟踪这些对象，那么应该考虑使用工厂
				方法模式。工厂方法集中地在一个地方创建对象，使对象跟踪变得更容易。注意，创建多个工厂方法也完全没有问题，
				实践中通常也这么做，对相似的对象创建进行逻辑分组，每个工厂方法负责一个分组。例如，有一个工厂方法负责连接到不同的
				数据库（MySQL、SQLite），另一个工厂方法负责创建要求的 几何对象（圆形、三角形），等等

				若需要将对象的创建和使用解耦，工厂方法也能派上用场

				另外一个值得一提的应用案例与应用性能及内存使用相关。工厂方法可以在必要时创建新的对象，从而提高性能和内存使用率。
				若直接实例化类来创建对象，那么每次创建新对象就需要分配额外的内存（除非这个类内部使用了缓存，一般情况下不会这 样）。
				例如类的两次实例化的内存地址不同

			实现代码：

		抽象工厂 ：
			抽象工厂设计模式是抽象方法的一种泛化。概括来说，一个抽象工厂是（逻辑上的）一组工厂方法，其中的每个工厂方法负责产生不同种类的对象


			现实生活的例子：
				汽车制造业应用了抽象工厂的思想。冲压不同汽车模型的部件（车门、仪表盘、车篷、挡泥板及反光镜等）所使用的机件是相同的。
				机件装配起来的模型随时可配置，且易于改变。

			软件的例子：
				程序包django_factory是一个用于在测试中创建Django模型的抽象工厂实现，可用来为支持测试专有属性的模型创建实例。
				这能让测试代码的可读性更高，且能避免共享不必要的代码，故有其存在的价值


			应用案例：
				为抽象工厂模式是工厂方法模式的一种泛化，所以它能提供相同的好处。这样会产生一个问题：我们怎么知道何时该使用工厂方法，
				何时又该使用抽象工厂？答案是， 通常一开始时使用工厂方法，因为它更简单。如果后来发现应用需要许多工厂方法，那么将创建
				一系列对象的过程合并在一起更合理，从而最终引入抽象工厂。

				抽象工厂有一个优点，在使用工厂方法时从用户视角通常是看不到的，那就是抽象工厂能够通过改变激活的工厂方法动态地（运行时）
				改变应用行为。一个经典例子是能够让用户在使用应用时改变应用的观感（比如，Apple风格和Windows风格等），
				而不需要终止应用然后重新启动

		工厂模式总结：
			两种模式都可以用于以下几种 场景：(a)想要追踪对象的创建时，(b)想要将对象的创建与使用解耦时，(c)想要优化应用的性能和资源占用时。

			工厂方法设计模式的实现是一个不属于任何类的单一函数，负责单一种类对象（一个形状、 一个连接点或者其他对象）的创建。

			抽象工厂设计模式的实现是同属于单个类的许多个工厂方法用于创建一系列种类的相关对象（一辆车的部件、一个游戏的环境，或者其他对象）。


	2.建造者模式：
		我们想要创建一个由多个部分构成的对象，而且它的构成需要一步接一步地完成。只有当各个部分都创建好，这个对象才算是完整的。
		这正是建造者设计模式（Builder design pattern）的用武之地。建造者模式将一个复杂对象的构造过程与其表现分离，这样，
		同一个构造过程可用于创建多个不同的表现。

		实际例子：
			HTML页面生成问题可以使用建造者模式来解决。该模式中，有两个参与者：建造者（builder）和指挥者（director）。
			建造者负责创建复杂对象的各个组成部分。在HTML例子中，这些组成部分是页面标题、文本标题、内容主体及页脚。
			指挥者使用一个建造者实例控制建造的过程。对于 HTML示例，这是指调用建造者的函数设置页面标题、文本标题等。
			使用不同的建造者实例让我们可以创建不同的HTML页面，而无需变更指挥者的代码。

		现实生活的例子：
			快餐店使用的就是建造者设计模式。

		软件的例子：
			django-widgy
				是一个 Django的第三方树编辑器扩展，可用作内容管理系统（Content Management System，CMS）。它
				包含一个网页构建器，用来创建具有不同布局的HTML页面

			django-query-builder
				是另一个基于建造者模式的Django第三方扩展库，该扩展库可用于动态地构建SQL查询。使用它，我们能够控制一个查询的方方面面，
				并能创建不同种类的查询，从简 单的到非常复杂的都可以

		应用场景：
			如果我们知道一个对象必须经过多个步骤来创建，并且要求同一个构造过程可以产生不同的表现，就可以使用建造者模式。这种需求存在
			于许多应用中，例如页面生成器（HTML页面生成器之类）、文档转换器以及用户界面（User Interface， UI）表单创建工具


		工厂模式和建造者模式的的区别：
			在工厂模式下，会立即返回一个创建好的对象；而在建造者模式下，仅在需要时客户端代码才显式地请求指挥者返回最终的对象

			简单明了的例子：
				买电脑的例子也许有助于区分建造者模式和工厂模式。
					假设你想购买一台新电脑，如果决定购买一台特定的预配置的电脑型号，则是在使用工厂模式。
					假设你想定制一台新电脑，使用的即是建造者模式。你是指挥者，向制造商（建造者）提供指令说明心中理想的电脑规格。


		建造者模式的总结：
			本章中，我们学习了如何使用建造者设计模式。可以在工厂模式（工厂方法或抽象工厂）不适用的一些场景中使用建造者模式创建对象。
			在以下几种情况下，与工厂模式相比，建造者模式 是更好的选择。
				1. 想要创建一个复杂对象（对象由多个部分构成，且对象的创建要经过多个不同的步骤， 这些步骤也许还需遵从特定的顺序）。
				2. 要求一个对象能有不同的表现，并希望将对象的构造与表现解耦。
				3. 想要在某个时间点创建对象，但在稍后的时间点再访问


	3.原型模式：
		原型设计模式（Prototype design pattern）
			帮助我们创建对象的克隆，其最简单的形式就是一个clone函数，接受一个对象作为输入参数，返回输入对象的一个副本。在Python中，
			这可以使用copy.deepcopy()函数来完成。

		现实生活的例子:
			原型设计模式无非就是克隆一个对象。有丝分裂，即细胞分裂的过程，是生物克隆的一个例子。
			另一个著名的（人工）克隆例子是多利羊

		软件的例子：
			很多Python应用都使用了原型模式，但几乎都不称之为原型模式，因为对象克隆是编程语言的一个内置特性。

			可视化工具套件（Visualization Toolkit，VTK）
				是原型模式的一个应用。VTK是一个开源的跨平台系统，用于三维计算机图形/图片处理以及可视化。VTK使用原型模式来创建几何元素
				（比如，点、线、六面体等）的克隆。
			music21
				也是使用原型模式的项目。根据该项目页面所述，“music21是一组工具，帮助学者和其他积极的听众快速简便地得到音乐相关问题
				的答案”。 music21工具套件使用原型模式来复制音符和总谱。

		应用案例：
			当我们已有一个对象，并希望创建该对象的一个完整副本时，原型模式就派上用场了。在我们知道对象的某些部分会被变更但又希望保持
			原有对象不变之时，通常需要对象的一个副本。在这样的案例中，重新创建原有对象是没有意义的。

			另一个案例是，当我们想复制一个复杂对象时，使用原型模式会很方便。对于复制复杂对象，我们可以将对象当作是从数据库中获取的，并引用
			其他一些也是从数据库中获取的对象。若通过多次重复查询数据来创建一个对象，则要做很多工作。在这种场景下使用原型模式要方便得多。

			深副本与浅副本。
				深副本：原始对象的所有数据都被简单地复制到克隆对象中，没有例外。
				浅副本：则依赖引用，我们可以引入数据共享和写时复制一类的技术来优化性能（例如，减小克隆对象的创建时间）和内存使用。
				如果可用资源有限（例如，嵌入式系统）或性能至关重 要（例如，高性能计算），那么使用浅副本可能更佳。

			在Python中，可以使用copy.copy函数进行浅复制。以下内容引用自Python官方文档，说明了浅副本copy.copy和
			深副本（copy.deepcopy()）之间的区别。
				浅副本构造一个新的复合对象后，（会尽可能地）将在原始对象中找到的对象的引用插入新对象中。
				深副本构造一个新的复合对象后，会递归地将在原始对象中找到的对象的副本插入新对象中。



		原型模式的总结：
			原型模式用于创建对象的完全副本。确切地说，创建一个对象的副本可以指代以下两件事情。
				第一种：当创建一个浅副本时，副本依赖引用
				第二种：当创建一个深副本时，副本复制所有东西

			第一种情况中：
				我们关注提升应用性能和优化内存使用，在对象之间引入数据共享，但需要小心地修改数据，因为所有变更对所有副本都是可见的。
				浅副本在本章中没有过多介绍，但也许 你会想试验一下。
			第二种情况中：
				我们希望能够对一个副本进行更改而不会影响其他对象。对于我们之前看到的蛋糕食谱示例这类案例，这一特性是很有用的。
				这里不会进行数据共享，所以需要关注因对象 克隆而引入的资源耗用问题。


结构型设计模式
	结构型设计模式处理一个系统中不同实体（比如，类和对象）之间的关系，关注的是提供一种简单的对象组合方式来创造新功能。可用于实现不兼容
	软件之间的接口兼容。


	4.适配器模式：

		适配器模式（Adapter pattern）是一种结构型设计模式，帮助我们实现两个不兼容接口之间的兼容。

			解释一下不兼容接口的真正含义。如果我们希望把一个老组件用于一个新系统中，或者把一个新组件用于一个老系统中，
			不对代码进行任何修改两者就能够通信的情况很少见。但 又并非总是能修改代码，或因为我们无法访问这些代码（例如，
			组件以外部库的方式提供），或因为修改代码本身就不切实际。在这些情况下，我们可以编写一个额外的代码层，
			该代码层包含让两个接口之间能够通信需要进行的所有修改。这个代码层就叫适配器。

			电子商务系统是这方面众所周知的例子。假设我们使用的一个电子商务系统中包含一个 calculate_total(order)函数。
			这个函数计算一个订单的总金额，但货币单位为丹麦克朗（DanishKroner，DKK）。顾客让我们支持更多的流行货币，
			比如美元（United States Dollar，USD）和欧元（Euro，EUR），这是很合理的要求。如果我们拥有系统的源代码，
			那么可以扩展系统，方法是添加一些新函数，将金额从DKK转换成USD，或者从DKK转换成EUR。但是如果应用仅以外部库的方式提供，
			我们无法访问其源代码，那又该怎么办呢？在这种情况下，我们仍然可以使用这个外部库（例如，调用它的方法），但无法修改和扩展它。
			解决方案是编写一个包装器（又名适配器）将数据从给定的DKK格式转换成期望的USD或EUR格式。

		现实生活的例子：
			我们所有人每天都在使用适配器模式，只不过是硬件上的，而不是软件上的。例如：USB适配器、电源插头适配器

		软件的例子：
			Grok是一个Python框架，运行在Zope3之上，专注于敏捷开发。Grok框架使用适配器，让已有对象无需变更就能符合指定API的标准
			Python第三方包Traits也使用了适配器模式，将没有实现某个指定接口（或一组接口）的对象 转换成实现了接口的对象。

		应用案例：
			在某个产品制造出来之后，需要应对新的需求之时，如果希望其仍然有效，则可以使用适配器模式。通常两个不兼容接口中的一个是他方的
			或者是老旧的。 如果一个接口是他方的，就意味着我们无法访问其源代码。如果是老旧的，那么对其重构通常是不切实际的。更进一步，
			我们可以说修改一个老旧组件的实现以满足我们的需求，不仅是不切实际的，而且也违反了开放封闭原则。

			开放封闭原则（open/close principle）是面向对象设计的基本原则之一（SOLID中的O），声明一个软件实体应该对扩展是开 放的，
			对修改则是封闭的。本质上这意味着我们应该无需修改一个软件实体的源代码就能扩展其行为。适配器模式遵从开放/封闭原则

			因此，在某个产品制造出来之后，需要应对新的需求之时，如果希望其仍然有效，使用适配器是一种更好的方式，原因如下所示：
				1. 不要求访问他方接口的源代码
				2. 不违反开放/封闭原则

		适配器模式小结：
			我们使用适配器模式让两个（或多个）不兼容接口兼容。

			适配器让一件产品在制造出来之后需要应对新需求之时还能工作。Python框架Grok和第三方包Traits各自都使用了适配器模式来获得API
			一致性和接口兼容性。开放/封闭原则与这些方面密切相关。

			适配器模式的使用，无需修改不兼容模型的源代码就能获得接口的一致性。这是通过让一个通用的适配器类完成相关工作而实现的。
			虽然在Python中我们可以沿袭传统方式使用子类（继承）来实现适配器模式，但这种技术是一种很棒的替代方案。


	5.修饰器模式：

		无论何时我们想对一个对象添加额外的功能，都有下面这些不同的可选方法。
			1. 如果合理，可以直接将功能添加到对象所属的类（例如，添加一个新的方法）
			2. 使用组合
			3. 使用继承




		与继承相比，通常应该优先选择组合，因为继承使得代码更难复用，继承关系是静态的，并且应用于整个类以及这个类的所有实例

		修饰器模式：
			设计模式为我们提供第四种可选方法，以支持动态地（运行时）扩展一个对象的功能，这种方法就是修饰器。修饰器（Decorator）
			模式能够以透明的方式（不会影响其他对象）动态地将功能添加到一个对象中。


			在许多编程语言中，使用子类化（继承）来实现修饰器模式。在Python中，我们可以（并且应该）使用内置的修饰器特性。
			一个Python修饰器就是对Python语法的一个特定改变，用于扩展一个类、方法或函数的行为，而无需使用继承。从实现的角度来说，
			Python修饰器是一个可调用对象（函数、方法、类），接受一个函数对象fin作为输入，并返回另一个函数对象fout。
			这意味着可以将任何具有这些属性的可调用对象当作一个修饰器。


		现实生活的例子：
			修饰器模式通常用于扩展一个对象的功能。这类扩展的实际例子有，给枪加一个消音器、使用不同的照相机镜头（在可拆卸镜头的照相机上）等。


		软件的例子：
			Django框架大量地使用修饰器，其中一个例子是视图修饰器。Django的视图（View）修饰器 可用于以下几种用途：
				1. 限制某些HTTP请求对视图的访问
				2. 控制特定视图上的缓存行为
				3. 按单个视图控制压缩
				4. 基于特定HTTP请求头控制缓存

			Grok框架也使用修饰器来实现不同的目标，比如下面几种情况：
				1. 将一个函数注册为事件订阅者
				2. 以特定权限保护一个方法
				3. 实现适配器模式

		应用案例：
			当用于实现横切关注点（cross-cutting concerns）时，修饰器模式会大显神威。以下是横切关注点的一些例子。：
				 1. 数据校验
				 2. 事务处理（这里的事务类似于数据库事务，意味着要么所有步骤都成功完成，要么事务失败）
				 3. 缓存
				 4. 日志
				 5. 监控
				 6. 调试
				 7. 业务规则
				 8. 压缩
				 9. 加密

			横切关注点的概念:
				一般来说，应用中有些部件是通用的，可应用于其他部件，这样的部件被看作横切关注点。

			使用修饰器模式的另一个常见例子是图形用户界面工具集。在一个GUI工具集中，我们希望能够将一些特性，比如边框、阴影、颜色以及滚屏，
			添加到单个组件/部件。

		实现：
			Python修饰器通用并且非常强大。你可以在Python官网python.org的修饰器代码库页面中找到许多修饰器的使用样例。本节中，
			我们将学习如何实现一个memoization修饰器。所有递归函数都能因memoization而提速，那么来试试常用的斐波那契数列例子。
			使用递归算法实现斐波那契数列，直接了当，但性能问题较大，即使对于很小的数值也是如此。


		修饰器模式小结：
			我们使用修饰器模式来扩展一个对象的行为，无需使用继承，非常方便。Python进一步扩展了修饰器的概念，
			允许我们无需使用继承或组合就能扩展任意可调用对象（函数、方法或类）的行为。我们可以使用Python内置的修饰器特性。

			修饰器模式是实现横切关注点的绝佳方案，因为横切关注点通用但不太适合使用面向对象编程范式来实现。修饰器可以帮助我们保持函数简洁，
			同时不牺牲性能。


 	6.外观模式：
 		外观设计隐藏了系统的内部复杂性，并通过一个简化的接口向客户端暴露必要的部分。本质上，外观（Facade）是在已有复杂系统之上实现的
 		一个抽象层。

 		现实生活的例子：
 			企业的客服部门，汽车或摩托车的启动钥匙、计算机、电视等通过一个简单按钮就能激活的复杂电子设备

 		软件的例子：
 			django-oscar-datacash模块是Django的一个第三方组件，用于集成DataCash支付网关。该组件有一个Gateway类，
 			提供对多种DataCash API的细粒度访问。在那之上，它也包含一个Facade类，提供粗粒度API（提供给那些不需要处理细节的人），
 			并针对审计目的提供保存事务的能力。

 			Caliendo是一个用于模拟Python API的的接口，它包含一个f
 			acade模块。该模块使用外观模式来完成许多不同但有用的事情（比如缓存方法），并基于传给顶层Facade方法的输入对象决定返回什么方法。

 		应用案例：
 			使用外观模式的最常见理由是为一个复杂系统提供单个简单的入口点。引入外观之后，客户端代码通过简单地调用一个方法/函数就能使用
 			一个系统。同时，内部系统并不会丢失任何功能， 外观只是封装了内部系统。

 			不把系统的内部功能暴露给客户端代码有一个额外的好处：我们可以改变系统内部，但客户端代码不用关心这个改变，
 			也不会受这个改变的影响。客户端代码不需要进行任何改变。

 			如果你的系统包含多层，外观模式也能派上用场。你可以为每一层引入一个外观入口点，并让所有层级通过它们的外观相互通信。
 			这提高了层级之间的松耦合性，尽可能保持层级独立

 		外观模式小结：
 			在客户端代码想要使用一个复杂系统但又不关心系统复杂性之时，这种模式是为复杂系统提供一个简单接口的理想方式。
 			一台计算机是一个外观， 因为当我们使用它时需要做的事情仅是按一个按钮来启动它；其余的所有硬件复杂性都用户无感知地交由BIOS、
 			引导加载程序以及其他系统软件来处理。现实生活中外观的例子更多，比如，我们所致电的银行或公司客服部门，
 			还有启动机动车所使用的钥匙。

 			我们讨论了两个使用外观的Django第三方组件：django-oscar-datacash和Caliendo。前者使用外观模式来提供一个简单的DataCash 
 			API以及保存事务的能力，后者为多种目的使用了外观，比如，缓存、基于输入对象的类型决定应该返回什么。


 	7.享元模式：
 		享元设计模式通过为相似对象引入数据共享来小化内存使用，提升性能。一个享元（Flyweight）就是一个包含状态独立的不可变（又称固有的）
 		数据的共享对象。


 		现实生活的例子：
 			享元模式是一个用于优化的设计模式。因此，要找一个合适的现实生活的例子不太容易。我们可以把享元看作现实生活中的缓存区。例如，
 			许多书店都有专用的书架来摆放新和流行的出版物。这就是一个缓存区，你可以先在这些专用书架上看看有没有正在找的书籍，如果没找到， 
 			则可以让图书管理员来帮你。

 		软件的例子：
 			Exaile音乐播放器使用享元来复用通过相同URL识别的对象（在这里是指音乐歌曲）。创建一个与已有对象的URL相同的新对象是没有意义的，
 			所以复用相同 的对象来节约资源。Peppy是一个用Python语言实现的类XEmacs编辑器，它使用享元模式存储major mode状态栏的状态。
 			这是因为除非用户修改，否则所有状态栏共享相同的属性。

 		应用案例：
 			享元旨在优化性能和内存使用。所有嵌入式系统（手机、平板电脑、游戏终端和微控制器等）和性能关键的应用（游戏、
 			3D图形处理和实时系统等）都能从其获益。若想要享元模式有效，需要满足GoF的《设计模式》一书罗列的以下几个条件：
				1. 应用需要使用大量的对象。
				2. 对象太多，存储/渲染它们的代价太大。一旦移除对象中的可变状态（因为在需要之时，应该由客户端代码显式地传递给享元），
				    多组不同的对象可被相对更少的共享对象所替代。
				3. 对象ID对于应用不重要。对象共享会造成ID比较的失败，所以不能依赖对象ID（那些在客户端代码看来不同的对象，终具有相同的ID）


		享元模式的小结：
			在我们想要优化内存使用提高应用性能之时，可以使用享元。在所有内存受限（想一想嵌入式系统）或关注性能的系统（比如图形软件和电子
			游戏）中，这一点相当重要。基于GTK+的Exaile音乐播放器使用享元来避免对象复制，Peppy文本编辑器则使用享元来共享状态栏的属性。


			一般来说，在应用需要创建大量的计算代价大但共享许多属性的对象时，可以使用享元。重点在于将不可变（可共享）
			的属性与可变的属性区分开。我们实现了一个树渲染器，支持三种不同的树家族。通过显式地向render方法提供可变的年龄和x,y属性，
			我们成功地仅创建了3个不同的对象，而不是18个。


	8.模型—视图—控制器模式：

		关注点分离（Separation of Concerns，SoC）原则是软件工程相关的设计原则之一。SoC原则背后的思想是将一个应用切分成不同的部分，
		每个部分解决一个单独的关注点。。分层设计中的层次（数据访问层、业务逻辑层和表示层等）即是关注点的例子。使用SoC原则能简化软件应用的 
		开发和维护。


		模型—视图—控制器（Model-View-Controller，MVC）模式是应用到面向对象编程的Soc原则。

		MVC 被认为是一种架构模式而不是一种设计模式。架构模式与设计模式之间的区别在于前者比后者的 范畴更广。
			1. 模型是核心的部分，代表着应用的信息本源，包含和管理（业务）逻辑、数据、状态以及应用的规则。
			2. 视图是模型的可视化表现。视图的例子有，计算机图形用户界面、计算机终端的文本输出、智能手机的应用图形界面、PDF文档、饼	
			图和柱状图等。视图只是展示数据，并不处理数据。
			3. 控制器是模型与视图之间的链接/粘附。模型与视图之间的所有通信都通过控制器进行

		MVC的优势：
			无需修改模型就能使用多个视图的能力（甚至可以根据需要同时使用多个视图）。为了实现模型与其表现之间的解耦，
			每个视图通常都需要属于它的控制器。如果模型直接与特定视图通信，我们将无法对同一个模型使用多个视图（或者至少无法以
			简洁模块化的方式实现）。


		现实生活的例子：
			你造一栋新房子，通常会请不同的专业人员来完成安装管道和电路 、粉刷房子等。。。


		软件的例子：
			Web框架web2py是一个支持MVC模式的轻量级Python框架
			Django也是一个MVC框架，但是它使用了不同的命名约定。在此约定下，控制器被称为视图，视图被称为模板。Django使用名称模型—模板
			—视图（Model-Template-View，MTV）来替代MVC。

		应用案例：
			MVC是一个非常通用且大有用处的设计模式。这一模式提供了以下这些好处：

				1. 视图与模型的分离允许美工一心搞UI部分，程序员一心搞开发，不会相互干扰。
				2. 由于视图与模型之间的松耦合，每个部分可以单独修改或者扩展，不会相互影响。例如，添加一个新视图的成本很小，只要	
				为其实现一个控制器就可以了。
				3. 因为职责明晰，维护每个部分也更简单。

			在从头开始实现MVC时，请确保创建的模型很智能，控制器很瘦，视图很傻瓜。

				- 可以将具有以下功能的模型视为智能模型。
					1. 包含所有的校验/业务规则/逻辑
					2. 处理应用的状态
					3. 访问应用数据（数据库、云或其他）
					4. 不依赖UI

				- 可以将符合以下条件的控制器视为瘦控制器。
					1. 在用户与视图交互时，更新模型
					2. 在模型改变时，更新视图
					3. 如果需要，在数据传递给模型/视图之前进行处理
					4. 不展示数据
					5. 不直接访问应用数据
					6. 不包含校验/业务规则/逻辑

				- 可以将符合以下条件的视图视为傻瓜视图。
					1. 展示数据
					2. 允许用户与其交互
					3. 仅做小的数据处理，通常由一种模板语言提供处理能力（例如，使用简单的变量和循环控制）
					4. 不存储任何数据
					5. 不直接访问应用数据
					6. 不包含校验/业务规则/逻辑

		MVC模式总结：
			MVC是一个非常重要的设计模式，用于将应用组织成三个 部分：模型、视图和控制器。

			每个部分都有明确的职责。模型负责访问数据，管理应用的状态。视图是模型的外在表现。视图并非必须是图形化的；文本输出也是一种好视图。
			控制器是模型与视图之间的连接。MVC的恰当使用能确保终产出的应用易于维护、易于扩展。

			Python框架web2py使用MVC作为核心架构理念。即使是简单的web2py例子也使用了MVC来实现模块化和可维护性。Django也是一个MVC框架，
			但它使用的名称是MTV。

			使用MVC时，请确保创建智能的模型（核心功能）、瘦控制器（实现视图与模型之间通信的能力）以及傻瓜式的视图（外在表现，小化逻辑处理）。


	9.代理模式：

		在某些应用中，我们想要在访问某个对象之前执行一个或多个重要的操作，例如，访问敏感信息——在允许用户访问敏感信息之前，
		我们希望确保用户具备足够的权限。操作系统中也存在类似的情况，用户必须具有管理员权限才能在系统中安装新程序，
		这类操作通常使用代理设计模式（Proxy design pattern）来实现。

		以下是四种不同的知名代理类型：
			1. 远程代理：实际存在于不同地址空间（例如，某个网络服务器）的对象在本地的代理者。
 			2. 虚拟代理：用于懒初始化，将一个大计算量对象的创建延迟到真正需要的时候进行。
 			3. 保护/防护代理：控制对敏感对象的访问。
 			4. 智能（引用）代理：在对象被访问时执行额外的动作。此类代理的例子包括引用计数和线程安全检查。

 		现实生活的例子：
 			芯片（又名芯片密码）卡是现实生活中使用防护代理的一个好例子。借记或信用卡包含一个芯片，ATM机或读卡器需要先读取芯片；
 			在芯片通过验证后， 需要一个密码（PIN）才能完成交易。这意味着只有在物理地提供芯片卡并且知道密码时才能进行交易。

 			使用银行支票替代现金进行购买和交易是远程代理的一个例子。支票准许了对一个银行账户 的访问。

 		软件的例子：
 			Python的weakref模块包含一个proxy（）方法，该方法接受一个输入对象并将一个智能代理返回给该对象。弱引用是为对象添加
 			引用计数支持的一种推荐方式。

 			ZeroMQ是一组专注于分布式计算的自由开源软件项目。ZeroMQ的Python实现有一个代理模块，实现了一个远程代理。
 			该模块允许Tornado的处理程序在不同的远程进程中运行。

 		应用案例：
 			因为存在至少四种常见的代理类型，所以代理设计模式有很多应用案例，如下所示：

			1. 在使用私有网络或云搭建一个分布式系统时。在分布式系统中，一些对象存在于本地内存中，一些对象存在于远程计算机的内存	中。
			    如果我们不想本地代码关心两者之间的区别，那么可以创建一个远程代理来隐藏或封装，使得应用的分布式性质透明化。
			2. 因过早创建计算成本较高的对象导致应用遭受性能问题之时。使用虚拟代理引入懒初始化，仅在真正需要对象之时才创建，能够	
			    明显提高性能。
			3. 用于检查一个用户是否有足够权限来访问某个信息片段。如果应用要处理敏感信息（例如，医疗数据），我们会希望确保用户在	
			    被准许之后才能访问/修改数据。一个保护/防护 代理可以处理所有安全相关的行为。
			4. 应用（或库、工具集、框架等）使用多线程，而我们希望把线程安全的重任从客户端代码转移到应用。这种情况下，可以创建一个	
			    智能代理，对客户端隐藏线程安全的复杂性。
			5. 对象关系映射（Object-Relational Mapping，ORM）API也是一个如何使用远程代理的例子。包括Django在内的许多流行Web	
			    框架使用一个ORM来提供类OOP的关系型数据库访问。ORM是关系型数据库的代理，数据库可以部署在任意地方，本地或远程服务	
			    器都可以。


		代理模式小结：
			我们使用代理模式实现一个实际类的替代品，这样可以在访问实际类之前（或之后）做一些额外的事情。

			芯片卡和银行支票是人们每天都在使用的两个不同代理的例子。芯片卡是一个防护代理，而银行支票是一个远程代理。另外，
			一些流行软件中也使用代理。Python有一个weakref.proxy（）方法，使得创建一个智能代理非常简单。ZeroMQ的Python
			实现则使用了远程代理。

			我们讨论了几个代理模式的应用案例，包括性能、安全及向用户提供简单的API。在第二个代码示例中，我们实现一个保护代理来处理用户信息。
			这个例子可以以多种方式进行改进，特别是关于其安全缺陷和用户列表实际上未持久化（永久存储）的问题。


行为型模式：

	10.责任链模式：

		开发一个应用时，多数时候我们都能预先知道哪个方法能处理某个特定请求。然而，情况并非总是如此。例如，想想任意一种广播计算机网络，
		例如早的以太网实现。在广播计算机网络中，会将所有请求发送给所有节点（简单起见，不考虑广播域），
		但仅对所发送请求感兴趣的节点会处理请求。加入广播网络的所有计算机使用一种常见的媒介相互连接，

		如果一个节点对某个请求不感兴趣或者不知道如何处理这个请求，可以执行以下两个操作：
			1. 忽略这个请求，什么都不做
			2. 将请求转发给下一个节点


		责任链（Chain of Responsibility）模式用于让多个对象来处理单个请求时，或者用于预先不知道应该由哪个对象（来自某个对象链）
		来处理某个特定请求时。其原则 如下所示：

			1. 存在一个对象链（链表、树或任何其他便捷的数据结构）。
			2. 我们一开始将请求发送给链中的第一个对象。
			3. 对象决定其是否要处理该请求。
			4. 对象将请求转发给下一个对象。
			5. 重复该过程，直到到达链尾。

		客户端代码仅知道第一个处理元素，而非拥有对所有处理元素的引用；并且每个处理元素仅知道其直接的下一个邻居（称为后继），
		而不知道所有其他处理元素。这通常是一种单向关系，用编程术语来说是一个单向链表，与之相反的是双向链表。单向链表不允许双向地遍历元素，
		双向链表则是允许的。这种链式组织方式大有用处：可以解耦发送方（客户端）和接收方（处理元素）


		现实生活的例子：
			ATM机以及及一般而言用于接收/返回钞票或硬币的任意类型机器（比如，零食自动贩卖机）都使用了责任链模式。
			机器上总会有一个放置各种钞票的槽口，钞票放入之后，会被传递到恰当的容器。钞票返回时，则是从恰当的容器中获取，
			我们可以把这个槽口视为共享通信媒介，不同的容器则是处理元素。结果包含来自一个或多个容器的现金。

		软件的例子：
			我试过寻找一些使用责任链模式的Python应用的好例子，但是没找到，很可能是因为Python程序员不使用这个名称。因此，很抱歉，
			我将使用其他编程语言的例子作为参考。

			Java的servlet过滤器是在一个HTTP请求到达目标处理程序之前执行的一些代码片段。在使用servlet过滤器时，有一个过滤器链，
			其中每个过滤器执行一个不同动作（用户身份验证、记日志、数据压缩等），并且将请求转发给下一个过滤器直到链结束；如果发生错误
			（例如，连续三次身 份验证失败）则跳出处理流程。

			Apple的Cocoa和Cocoa Touch框架使用责任链来处理事件。在某个视图接收到一个其并不知道如何处理的事件时，
			会将事件转发给其超视图，直到有个视图能够处理这个事件或者视图链结束。

		应用案例：
			通过使用责任链模式，我们能让许多不同对象来处理一个特定请求。在我们预先不知道应该由哪个对象来处理某个请求时，这是有用的。
			其中一个例子是采购系统。在采购系统中，有许多核准权限。某个核准权限可能可以核准在一定额度之内的订单，假设为100美元。
			如果订单超过了100美元，则会将订单发送给链中的下一个核准权限，比如能够核准在200美元以下的订单。

			另一个责任链可以派上用场的场景是，在我们知道可能会有多个对象都需要对同一个请求进行处理之时。这在基于事件的编程中是常有的事情。
			单个事件，比如一次鼠标左击，可被多个事件监听者捕获

			不过应该注意，如果所有请求都能被单个处理程序处理，责任链就没那么有用了，除非确实不知道会是哪个程序处理请求。
			这一模式的价值在于解耦。客户端与所有处理程序（一个处理程序与所有其他处理程序之间也是如此）之间不再是多对多关系，
			客户端仅需要知道如何与链的起始节点（标头）进行通信。

		实现：
			使用Python实现责任链模式有许多种方式，我们以Vespe的实现为参考实现一个简单的事件系统。


		责任链事件小结：
			了责任链设计模式。在无法预先知道处理程序的数量和类型时，该模式有助于对请求或处理事件进行建模。适合使用责任链模式的系统例子
			包括基于事件的系统、采购系统和运输系统。

			在责任链模式中，发送方可直接访问链中的首个节点。若首个节点不能处理请求，则转发给下一个节点，如此直到请求被某个节点处理或者
			整个链遍历结束。这种设计用于实现发送方与接收方（多个）之间的解耦。


			ATM机是责任链的一个例子。用于取放钞票的槽口可看作是链的头部。从这里开始，根据具体交易，一个或多个容器会被用于处理交易。
			这些容器可看作是链中的处理程序。

			Java的servlet过滤器使用责任链模式对一个HTTP请求执行不同的动作（例如，压缩和身份验证）。Apple的Cocoa框架使用相同的模式
			来处理事件，比如，按钮和手势。


	11.命令模式：

		命令设计模式
			命令设计模式帮助我们将一个操作（撤销、重做、复制、粘贴等）封装成一个对象。简而言之，这意味着创建一个类，
			包含实现该操作所需要的所有逻辑和方法。

				1. 我们并不需要直接执行一个命令。命令可以按照希望执行。
				2. 调用命令的对象与知道如何执行命令的对象解耦。调用者无需知道命令的任何实现细节。
				3. 如果有意义，可以把多个命令组织起来，这样调用者能够按顺序执行它们。例如，在实现一个多层撤销命令时，这是很有用的。

		现实生活的例子：
			当我们去餐馆吃饭时，会叫服务员来点单。他们用来做记录的账单（通常是纸质的）就是命令模式的一个例子。在记录好订单后，
			服务员将其放入账单队列，厨师会照着单子去做。每个账单都是独立的，并且可用来执行许多不同命令。


		软件的例子：
			PyQt是QT工具包的Python绑定。PyQt包含一个QAction类，将一个动作建模为一个命令。对每个动作都支持额外的可选信息，
			比如，描述、工具提示、快捷键和其他。
			git-cola是使用Python语言编写的一个Git GUI，它使用命令 模式来修改模型、变更一次提交、应用一个差异选择、签出。


		应用案例：
			许多开发人员以为撤销例子是命令模式的唯一应用案例。撤销操作确实是命令模式的杀手级 特性，然而命令模式能做的实际上还有很多：

				1. GUI按钮和菜单项：前面提过的PyQt例子使用命令模式来实现按钮和菜单项上的动作。
				2. 其他操作：除了撤销，命令模式可用于实现任何操作。其中一些例子包括剪切、复制、 粘贴、重做和文本大写。
				3. 事务型行为和日志记录：事务型行为和日志记录对于为变更记录一份持久化日志是很重要的。操作系统用它来从系统崩溃中恢复，	
				 关系型数据库用它来实现事务，文件系统用 它来实现快照，而安装程序（向导程序）用它来恢复取消的安装。
				4. 宏：在这里，宏是指一个动作序列，可在任意时间点按要求进行录制和执行。流行的编 辑器（比如，Emacs和Vim）都支持宏。

		命令模式小结：
			我们学习了命令模式。使用这种设计模式，可以将一个操作（比如，复制/粘贴） 封装为一个对象。这样能提供很多好处，如下所述：

				1. 我们可以在任何时候执行一个命令，而并不一定是在命令创建时。
				2. 执行一个命令的客户端代码并不需要知道命令的任何实现细节。
				3. 可以对命令进行分组，并按一定的顺序执行。

			虽然至今命令模式最广为人知的特性是撤销操作，但它还有更多用处。一般而言，要在运行时按照用户意愿执行的任何操作都适合使用命令模式。
			命令模式也适用于组合多个命令。这有助于实现宏、多级撤销以及事务。一个事务应该：要么成功，这意味着事务中所有操作应该都成功
			（提交操作）；要么如果至少一个操作失败，则全部失败（回滚操作）。


	12.解释器模式：
		对每个应用来说，至少有以下两种不同的用户分类：
			1. 基本用户：这类用户只希望能够凭直觉使用应用。他们不喜欢花太多时间配置或学习应用的内部。对他们来说，基本的用法就足够了。 
			2. 高级用户：这些用户，实际上通常是少数，不介意花费额外的时间学习如何使用应用的。高级特性。如果知道学会之后能得到以下好处，
			    他们甚至会去学习一种配置（或脚本）语言。
				1. 能够更好地控制一个应用
				2. 以更好的方式表达想法
				3. 提高生产力

			解释器（Interpreter）模式仅能引起应用的高级用户的兴趣。这是因为解释器模式背后的主要思想是让非初级用户和领域专家使用一门简单
			的语言来表达想法。

			领域特定语言(Domain Specific Language，DSL)DSL是一种针对一个特定领域的有限表达能力的计算机语言。很多不同的事情都使用DSL，
			比如，战斗模拟、记账、可视化、配置、通信协议等。DSL分为内部DSL和外部DSL:

				1. 内部DSL构建在一种宿主编程语言之上。内部DSL的一个例子是，使用Python解决线性方程组的一种语言。使用内部DSL的优势是我们
				不必担心创建、编译及解析语法，因为这些已经被宿主语言解决掉了。劣势是会受限于宿主语言的特性。如果宿主语言不具备这些特性，
				构建一种表达能力强、简洁而且优美的内部DSL是富有挑战性的

				2. 外部DSL不依赖某种宿主语言。DSL的创建者可以决定语言的方方面面（语法、句法等),但也要负责为其创建一个解析器和编译器。
				为一种新语言创建解析器和编译器是一个非常复杂、长期而又痛苦的过程。

			解释器模式仅与内部DSL相关。因此，我们的目标是使用宿主语言提供的特性构建一种简单但有用的语言，在这里，宿主语言是Python。注意，
			解释器根本不处理语言解析，它假设我们已 经有某种便利形式的解析好的数据，可以是抽象语法树（abstract syntax tree，AST）
			或任何其他好用的数据结构。


		现实生活的例子：
			音乐演奏者是现实中解释器模式的一个例子。五线谱图形化地表现了声音的音调和持续时间。音乐演奏者能根据五线谱的符号精确地重现声音。
			在某种意义上，五线谱是音乐的语言，音乐演奏者是这种语言的解释器

		软件的例子：

			内部DSL在软件方面的例子有很多。PyT是一个用于生成HTML的Python-DSL。PyT关注性能，并声称能与Jinja2的速度相媲美。当然，
			我们不能假定在PyT。中必须使用解释器模式。然而，PyT是一种内部DSL，非常适合使用解释器模式。


			Chromium是一个自由开源的浏览器软件，催生出了Google-Chrome浏览器。Chromium的Mesa库Python绑定的一部分使用解释器模式
			将C样板参数翻译成 Python对象并执行相关的命令。


		应用案例：

			在我们希望为领域专家和高级用户提供一种简单语言来解决他们的问题时，可以使用解释器模式。

			我们的目标是为专家提供恰当的编程抽象，使其生产力更高；这些专家通常不是程序员。理想情况下，他们使用我们的DSL并不需要了解
			高级Python知识，当然了解一点Python基础知识会更好，因为我们最终生成的是Python代码，但不应该要求了解Python高级概念。
			此外，DSL的性 能通常不是一个重要的关注点。重点是提供一种语言，隐藏宿主语言的独特性，并提供人类更易读的语法。诚然，
			Python已经是一门可读性非常高的语言，与其他编程语言相比，其古怪的语法更少。


		解析器模式总结：

			解释器模式用于为高级用户和领域专家提供一个类编程的框架，但没有暴露出编程语言那样的复杂性。这是通过实现一个DSL来达到目的的

			DSL是一种针对特定领域、表达能力有限的计算机语言。DSL有两类，分别是内部DSL和外部DSL。内部DSL构建在一种宿主编程语言之上，依	
			赖宿主编程语言，外部DSL则是从头实现，不依赖某种已有的编程语言。解释器模式仅与内部DSL相关。

			乐谱是一个非软件DSL的例子。音乐演奏者像一个解释器那样，使用乐谱演奏出音乐。从软件的视角来看，许多Python模板引擎都使用了内部DSL。
			PyT是一个高性能的生成(X)HTML的Python-DSL。我们也看到Chromium的Mesa库是如何使用解释器模式将图形相关的C代码翻译成 
			Python可执行对象的。


	13.观察者模式：

		有时，我们希望在一个对象的状态改变时更新另外一组对象。在MVC模式中有这样一个非常常见的例子，假设在两个视图
		（例如，一个饼图和一个电子表格）中使用同一个模型的数据，无论何时更改了模型，都需要更新两个视图。这就是观察者设计模式要处理的问题。

		观察者模式描述单个对象（发布者，又称为主持者或可观察者）与一个或多个对象（订阅者，又称为观察者）之间的发布—订阅关系。在MVC例子中，
		发布者是模型，订阅者是视图。

		观察者模式背后的思想等同于MVC和关注点分离原则背后的思想，即降低发布者与订阅者之间的耦合度，从而易于在运行时添加或删除订阅者。此外，
		发布者不关心它的订阅者是谁。它只是将通知发送给所有订阅者。


		现实生活的例子：
			现实中，拍卖会类似于观察者模式。每个拍卖出价人都有一些拍牌，在他们想出价时就可以举起来。不论出价人在何时举起一块拍牌，
			拍卖师都会像主持者那样更新报价，并将新的价格广 播给所有出价人（订阅者）。


		软件的例子：

			大体上，所有利用MVC模式的系统都是基于事件的。

			django-observer源代码包是一个第三方Django包，可用于注册回调函数，之后在某些Django模型字段发生变化时执行。
			它支持许多不同类型的模型字段 （CharField、IntegerField等）。

			RabbitMQ可用于为应用添加异步消息支持，支持多种消息协议（比如，HTTP和AMQP），可在Python应用中用于实现发布—订阅模式，
			也就是观察者设计模式。

		应用案例：

			当我们希望在一个对象（主持者/发布者/可观察者）发生变化时通知或更新另一个或多个对象的时候，通常会使用观察者模式。
			观察者的数量以及谁是观察者可能会有所不同，也可以（在运行时）动态地改变。

			同样的概念也存在于社交网络。如果你使用社交网络服务关联了另一个人，在关联的人更新某些内容时，你能收到相关通知，
			不论这个关联的人是你关注的一个Twitter用户，Facebook上的 一个真实朋友，还是LinkdIn上的一位同事。

			事件驱动系统是另一个可以使用（通常也会使用）观察者模式的例子。在这种系统中，监听者被用于监听特定事件。
			监听者正在监听的事件被创建出来时，就会触发它们。这个事件可以是键入（键盘的）某个特定键、移动鼠标或者其他。
			事件扮演发布者的角色，监听者则扮演观察者的角色。在这里，关键点是单个事件（发布者）可以关联多个监听者（观察者）


		观察者总结：
			若希望在一个对象的状态变化时能够通知或提醒所有相关者（一个对象或一组对象），则可以使用观察者模式。观察者模式的一个重要特性是，
			在运行时，订阅者/观察者的数量以及观察者是谁可能会变化，也可以改变。


	14.状态模式：

		面向对象编程着力于在对象交互时改变它们的状态。在很多问题中，有限状态机（通常名为状态机）是一个非常方便的状态转换建模
		（并在必要时以数学方式形式化）工具。

		状态机是一个抽象机器，有两个关键部分，状态和转换。状态是指系统的当前（激活）状况。。转换是指从一个状态切换到另一个状态，
		因某个事件或条件的触发而开始，通常，在一次转换发生之前或之后会执行一个或一组动作。

		进程一开始由用户创建好，就进入“已创建或新建”状态。这个状态只能切换到“等待”状态，这个状态转换发生在调度器将进程加载进内存
		并添加到“等待/预备执行”的进程队列之时。一个“等待”进程有两个可能的状态转换：可被选择而执行（切换到“运行”状态），
		或被更高优先级的进程所替代（切换到“换 出并等待”状态）。


		现实生活的例子:
			自动售货机有不同的状态，并根据我们放入的钱币数量作出不同反应。根据我们的选 择和放入的钱币，机器会执行以下操作。
				1. 拒绝我们的选择，因为请求的货物已售罄。
				2. 拒绝我们的选择，因为放入的钱币不足。
				3. 递送货物，且不找零，因为放入的钱币恰好足够。
				4. 递送货物，并找零。


		软件的例子:
			使用状态模式本质上相当于实现一个状态机来解决特定领域的一个软件问题。django-fsm程序包是一个第三方程序包，
			用于Django框架中简化状态机的实现和使用。

			另一个值得一提的项目是状态机编译器（State Machine Compiler，SMC）。使用SMC，你可以使用一种简单的领域特定语言在文本文件
			中描述你的状态机，SMC会自动生成状态机的代码。该项目声称这种DSL非常简单，写起来就像一对一地翻译一个状态图。

		应用案例：

			1. 状态模式适用于许多问题。所有可以使用状态机解决的问题都是不错的状态模式应用案例。 我们已经见过的一个例子是
			操作系统/嵌入式系统的进程模型。


			2. 编程语言的编译器实现是另一个好例子。词法和句法分析可使用状态来构建抽象语法树。

			3. 事件驱动系统也是另一个例子。在一个事件驱动系统中，从一个状态转换到另一个状态会触发一个事件或消息。许多计算机游戏都使用
				这一技术。例如，怪兽会在主人公接近时从防御状态 转换到攻击状态


		状态模式总结：
			状态模式是一个或多个有限状态机（简称状态机）的实 现，用于解决一个特定的软件工程问题。

			状态机是一个抽象机器，具有两个主要部分：状态和转换。状态是指一个系统的当前状况。一个状态机在任意时间点只会有一个激活状态。
			转换是指从当前状态到一个新状态的切换。在一个转换发生之前或之后通常会执行一个或多个动作。状态机可以使用状态图进行视觉上的展现。

			状态机用于解决许多计算机问题和非计算机问题，其中包括交通灯、停车计时器、硬件设计和编程语言解析等。
			我们也看到零食自动贩卖机是如何与状态机的工作方式相关联的。

			许多现代软件提供库/模块来简化状态机的实现与使用。Django提供第三方包django-fsm，Python也有许多大家贡献的模块。
			实际上，在14.4节就使用了其中的一个模块（state_machine）。 状态机编译器是另一个有前景的项目，提供许多编程语言的绑定
			（包括Python）。


		状态模式是一个或多个有限状态机（简称状态机）的实 现，用于解决一个特定的软件工程问题。

		状态机是一个抽象机器，具有两个主要部分：状态和转换。状态是指一个系统的当前状况。一个状态机在任意时间点只会有一个激活状态。
		转换是指从当前状态到一个新状态的切换。在一 个转换发生之前或之后通常会执行一个或多个动作。状态机可以使用状态图进行视觉上的展现。

		状态机用于解决许多计算机问题和非计算机问题，其中包括交通灯、停车计时器、硬件设计和编程语言解析等。
		我们也看到零食自动贩卖机是如何与状态机的工作方式相关联的。


	15.策略模式：

		大多数问题都可以使用多种方法来解决。以排序问题为例，对于以一定次序把元素放入一个列表，排序算法有很多。通常来说，
		没有公认适合所有场景的算法。 一些不同的评判标准能帮助我们为不同的场景选择不同的排序算法，其中应该考虑的有以下几个：

			1. 需要排序的元素数量：这被称为输入大小。当输入较少时，几乎所有排序算法的表现都很好，但对于大量输入，只有部分算法具有不错	
			    的性能。
			2. 算法的最佳/平均/最差时间复杂度：时间复杂度是算法运行完成所花费的（大致）时间长短，不考虑系数和低阶项。这是选择算法的常	
			    见标准，但这个标准并不总是那么充分。
 			3. 算法的空间复杂度：空间复杂度是充分地运行一个算法所需要的（大致）物理内存量。在我们处理大数据或在嵌入式系统（通常内存有	
 			    限）中工作时，这个因素非常重要。
 			4. 算法的稳定性：在执行一个排序算法之后，如果能保持相等值元素原来的先后相对次序， 则认为它是稳定的。
 			5. 算法的代码实现复杂度：如果两个算法具有相同的时间或空间复杂度，并且都是稳定的，那么知道哪个算法更易于编码实现和维护也是	
 			    很重要的。

 		策略模式的目的：

 			可能还有更多的评判标准值得考虑，但重要的是，我们真的只能使用单个排序算法来应对所有情况吗？答案当然不是。
 			一个更好的方案是把所有排序算法纳为己用，然后使用上面提到的标准针对当前情况选择好的算法。这就是策略模式的目的。

 		策略模式（Strategy pattern）

 			鼓励使用多种算法来解决一个问题，其杀手级特性是能够在运行时透明地切换算法（客户端代码对变化无感知）。因此，如果你有两种算法，
 			并且知道其中一种对少量输入效果更好，另一种对大量输入效果更好，则可以使用策略模式在运行时基于输入数据决定使用哪种算法。

 		现实生活的例子：
 			去机场赶飞机是现实中使用策略模式的一个恰当例子。

				1. 如果想省钱，并且早点出发，那么可以坐公交车/地铁。
				2. 如果不介意支付停车费，并且有自己的汽车，那么可以开车去。
				3. 如果没有自己的车，又比较急，则可以打车。

			这是费用、时间、便利性等因素之间的一个折中权衡。

		软件的例子：
			Python 的 sorted() 和 list.sort()函数是策略模式的例子。两个函数都接受一个命名参数key，这个参数本质上是实现了
			一个排序策略的函数的名称.


		应用案例：
			策略模式是一种非常通用的设计模式，可应用的场景很多。一般来说，不论何时希望动态、透明地应用不同算法，策略模式都是可行之路。
			这里所说不同算法的意思是，目的相同但实现方案不同的一类算法。这意味着算法结果应该是完全一致的，但每种实现都有不同的性能和
			代码复杂性（举例来说，对比一下顺序查找和二分查找）。

			策略模式并不限于排序问题，也可用于创建各种不同的资源过滤器（身份验证、日志记录、数据压缩和加密等）

			策略模式的另一个应用是创建不同的样式表现，为了实现可移植性（例如，不同平台之间断行的不同）或动态地改变数据的表现。


			另一个值得一提的应用是模拟；例如模拟机器人，一些机器人比另一些更有攻击性，一些机器人速度更快，等等。机器人行为中的所有不同
			之处都可以使用不同的策略来建模。


		策略模式小结：
			策略模式通常用在我们希望对同一个问题透明地使用多种方案时。如果并不存在针对所有输入数据和所有情况的完美算法，那么我们可以使用
			策略模式， 动态地决定在每种情况下应使用哪种算法。现实中，在我们想赶去机场乘飞机时会使用策略模式。

			Python使用策略模式让客户端代码决定如何对一个数据结构中的元素进行排序。我们看到了一个例子，基于TIOBE指数排行榜对编程语言
			进行排序。

			策略设计模式的使用并不限于排序领域。加密、压缩、日志记录及其他资源处理的领域都可以使用策略模式来提供不同的数据处理方式。
			可移植性是策略模式的另一个用武之地。模拟也是 另一个策略模式适用的领域。

			通过实现两种不同算法来检测一个单词中所有字符的唯一性，我们学习了Python如何因其具 有一等函数而简化了策略模式的实现。


	16.模板模式：

		编写优秀代码的一个要素是避免冗余。在面向对象编程中，方法和函数是我们用来避免编写冗余代码的重要工具。


		现实生活的例子：
			工人的日程，特别是对于同一个公司的工人而言，非常接近于模板设计模式。所有工人都遵从或多或少相同的例行流程，但例行流程的
			某些特定部分区别又很大。


		软件的例子：

			Python在cmd模块中使用了模板模式，该模块用于构建面向行的命令解释器。具体而言， cmd.Cmd.cmdloop()实现了一个算法，
			持续地读取输入命令并将命令分发到动作方法。每次循环之前、之后做的事情以及命令解析部分始终是相同的。
			这也称为一个算法的不变部分。变化的 是实际的动作方法（易变的部分）。

			Python的asyncore模块也使用了模板模式，该模块用于实现异步套接字服务客户端、服务器。
			其中诸如asyncore.dispatcher.handle_connect_event和asyncore.dispatcher. handle_write_event()之类的方法
			仅包含通用代码。要执行特定于套接字的代码，这两个方 法会执行handle_connect()方法。注意，执行的是一个特定于套接字
			的handle_connect()，不是asyncore.dispatcher.handle_connect()。后者仅包含一条警告。可以使用inspect模块来查看



		应用案例：

			模板设计模式旨在消除代码重复。如果我们发现结构相近的（多个）算法中有重复代码，则可以把算法的不变（通用）部分留在一个
			模板方法/函数中，把易变（不同）的部分移到动作/钩 子方法/函数中。

			页码标注是一个不错的模板模式应用案例。一个页码标注算法可以分为一个抽象（不变的）部分和一个具体（易变的）部分。
			不变的部分关注的是大行号/页号这部分内容。易变的部分 则包含用于显示某个已分页特定页面的页眉和页脚的功能。

			所有应用框架都利用了某种形式的模板模式。在使用框架来创建图形化应用时，通常是继承自一个类，并实现自定义行为。然而，
			在执行自定义行为之前，通常会调用一个模板方法，该方法实现了应用中一定相同的部分，比如绘制屏幕、处理事件循环、
			调整窗口大小并居中等等

		模板模式小结：
			我们学习了模板设计模式。在实现结构相近的算法时，可以使用模板模式来消除冗 余代码。具体实现方式是使用动作/钩子方法/函数来
			完成代码重复的消除，它们是Python中的一 等公民。我们学习了一个实际的例子，即使用模板模式来重构BFS和DFS算法的代码。

























